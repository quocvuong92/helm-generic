<p align="center">
  <img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/kubernetes.svg" alt="Kubernetes" width="80" height="80">
</p>

{{ template "chart.header" . }}

<p align="center">
  <img src="https://img.shields.io/badge/Version-{{ .Version }}-informational?style=flat-square" alt="Version: {{ .Version }}">
  <img src="https://img.shields.io/badge/Type-{{ .Type }}-informational?style=flat-square" alt="Type: {{ .Type }}">
  <img src="https://img.shields.io/badge/AppVersion-{{ .AppVersion }}-informational?style=flat-square" alt="AppVersion: {{ .AppVersion }}">
</p>

{{ template "chart.description" . }}

## Features

- **Multiple Workload Types** - Deployment, StatefulSet, DaemonSet, or CronJob with explicit `workload.type` selector
- **Validation** - Fail-fast with clear error messages for invalid configurations
- **Multi-port Services** - Configure multiple container and service ports
- **Sidecar Containers** - Add init containers and sidecars to your pods
- **Multi-backend Ingress** - Route different paths to different services
- **Environment Variables** - Support for direct env vars, secretEnv, and envFrom
- **Config/Secret Mounting** - Mount configuration files with automatic pod rollover on changes
- **HorizontalPodAutoscaler** - With CPU, memory, and custom metrics support
- **PodDisruptionBudget** - Ensure high availability during disruptions
- **NetworkPolicy** - Control pod network traffic
- **ServiceMonitor** - Prometheus Operator integration
- **RBAC** - Multiple Roles and ClusterRole support with multi-namespace bindings

## Requirements

Kubernetes: `{{ template "chart.kubeVersion" . }}`

## Installation

```bash
# Install with default values (Deployment with nginx)
helm install my-release generic

# Install with custom values
helm install my-release generic -f values.yaml

# Install in specific namespace
helm install my-release generic -n production --create-namespace
```

## Quick Start Examples

### Basic Deployment

```yaml
workload:
  type: deployment
  replicas: 2

image:
  repository: nginx
  tag: "1.25"

ports:
  - name: http
    containerPort: 80

service:
  ports:
    - name: http
      port: 80
      targetPort: 80
```

### StatefulSet with Persistent Storage

```yaml
workload:
  type: statefulset
  replicas: 3
  statefulset:
    podManagementPolicy: Parallel
    volumeClaimTemplates:
      - name: data
        size: 50Gi
        storageClassName: gp3

image:
  repository: postgres
  tag: "15"

ports:
  - name: postgres
    containerPort: 5432
```

### DaemonSet for Node-level Services

```yaml
workload:
  type: daemonset

image:
  repository: fluent/fluent-bit
  tag: "2.1"

pod:
  tolerations:
    - key: node-role.kubernetes.io/control-plane
      effect: NoSchedule
```

### CronJob for Scheduled Tasks

```yaml
workload:
  type: cronjob
  cronjob:
    schedule: "0 2 * * *"
    concurrencyPolicy: Forbid

image:
  repository: curlimages/curl
  tag: "8.1.0"

command: ["/bin/sh", "-c"]
args: ["curl -X POST https://api.example.com/backup"]

service:
  enabled: false
```

### Multi-port Service

```yaml
ports:
  - name: http
    containerPort: 80
  - name: grpc
    containerPort: 9090

service:
  ports:
    - name: http
      port: 80
      targetPort: 80
    - name: grpc
      port: 9090
      targetPort: 9090
```

### With Sidecar Containers

```yaml
pod:
  initContainers:
    - name: init-config
      image: busybox
      command: ["sh", "-c", "cp /config/* /app/"]

  sidecars:
    - name: log-shipper
      image: fluent/fluent-bit:2.1
      resources:
        limits:
          memory: 64Mi
```

### Multi-backend Ingress

```yaml
ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt
  hosts:
    - host: api.example.com
      paths:
        - path: /api
          pathType: Prefix
        - path: /admin
          pathType: Prefix
          serviceName: admin-service
          servicePort: 8080
  tls:
    - secretName: api-tls
      hosts:
        - api.example.com
```

### Configuration Files

```yaml
configFiles:
  - name: app-config
    mountPath: /etc/app/config.yaml
    content: |
      database:
        host: localhost
        port: 5432

secretFiles:
  - name: credentials
    mountPath: /etc/app/credentials.json
    content: |
      {"apiKey": "secret-value"}

secretEnv:
  - name: DB_PASSWORD
    value: "super-secret"
```

### Environment from Existing Secrets

```yaml
envFrom:
  - secretRef:
      name: my-existing-secret
  - configMapRef:
      name: my-existing-configmap
```

### Production Configuration

```yaml
workload:
  type: deployment
  replicas: 3

resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 500m
    memory: 512Mi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  metrics:
    cpu:
      enabled: true
      averageUtilization: 70

podDisruptionBudget:
  enabled: true
  minAvailable: 2

networkPolicy:
  enabled: true
  policyTypes:
    - Ingress

serviceMonitor:
  enabled: true
  path: /metrics
```

### RBAC Configuration

```yaml
serviceAccount:
  create: true
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789:role/my-role

rbac:
  roles:
    - name: my-app-role
      namespaces:
        - default
        - production
      rules:
        - apiGroups: [""]
          resources: ["configmaps"]
          verbs: ["get", "list", "watch"]

  clusterRole:
    enabled: true
    rules:
      - apiGroups: [""]
        resources: ["nodes"]
        verbs: ["get", "list"]
```

{{ template "chart.valuesSection" . }}

## Validation Rules

The chart validates configurations and fails with clear error messages:

| Condition | Error |
|-----------|-------|
| Invalid `workload.type` | Must be: deployment, statefulset, daemonset, cronjob |
| HPA with daemonset/cronjob | HPA only supports deployment and statefulset |
| PDB with cronjob | PDB cannot be used with cronjob |

{{ template "chart.maintainersSection" . }}

## License

MIT

{{ template "helm-docs.versionFooter" . }}
